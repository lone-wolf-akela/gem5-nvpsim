#pragma once

#include <iostream>
#include <fstream>
#include <array>
#include <vector>
#include <functional>
#include <utility>
#include <cassert>
#include <type_traits>
#include <cmath>
#include <string>
#include <stdexcept>
#include <cstdio>
#include <bitset>
//#include <filesystem>
#include <iterator>

//#define CPP17
#ifndef CPP17
#define static_assert(bExpress)
#define IF_CONSTEXPRESS if
#else
#define IF_CONSTEXPRESS if constexpr
#endif


class NotImplemented : public std::logic_error
{
public:
	NotImplemented() : std::logic_error("Function not yet implemented") {}
	NotImplemented(const char* what_arg) : std::logic_error(what_arg) {}
	NotImplemented(const std::string& what_arg) : std::logic_error(what_arg) {}
};

constexpr int NUM_LEN = 12;
constexpr int NUM_FRAC_BITS = 4;
constexpr int WNUM_FRAC_BITS = 7;

#define IN
#define OUT

//限定比特位数的整数类
template<int BitNum>
class Num
{
public:
	typedef int32_t ValueType;
	
	static_assert(BitNum > 0);
	static_assert(BitNum <= sizeof(ValueType) * 8 - 1);

	//这个构造函数检查输入值是否溢出；在debug模式下溢出时会中断程序；在release下溢出时运行不正确
	Num(const ValueType& value = 0);

	//这个构造函数的第二个参数其实未使用，只是用来与上一个构造函数区分
	//这个构造函数会对输入值进行截断(regulation)
	Num(const ValueType& value, bool /*regulation*/);

	//这个set函数检查输入值是否溢出；在debug模式下溢出时会中断程序；在release下溢出时运行不正确
	void set(const ValueType& value);

	//这个setRegulation函数会对输入值进行截断(regulation)
	void setRegulation(const ValueType& value);

	void setBit(int bit, const bool& v);

	bool getBit(int bit) const;

	Num<BitNum>& operator=(const ValueType& value);

	bool operator==(const ValueType& value) const;

	Num<BitNum> operator+(const Num<BitNum>& num) const;

	//不同于普通的加法，这种加法返回的值的比特数比加数和被加数大1，这样没有溢出风险
	Num<BitNum + 1> extendAdd(const Num<BitNum>& num) const;

	//extendAdd之后再changebit回原来bit数的加法；与普通加法的区别是符号位可以保持正确
	Num<BitNum> signKeepAdd(const Num<BitNum>& num) const;

	//在changebit前右移指定位数的signKeepAdd
	Num<BitNum> signKeepAdd(const Num<BitNum>& num, const int& rightShift) const;

	Num<BitNum> operator-() const;

	Num<BitNum> operator-(const Num<BitNum>& num) const;

	//不同于普通的减法，这种减法返回的值的比特数比减数和被减数大1，这样没有溢出风险
	Num<BitNum + 1> extendSub(const Num<BitNum>& num) const;

	//extendAdd之后再changebit回原来bit数的加法；与普通加法的区别是符号位可以保持正确
	Num<BitNum> signKeepSub(const Num<BitNum>& num) const;

	//在changebit前右移指定位数的signKeepAdd
	Num<BitNum> signKeepSub(const Num<BitNum>& num, const int& rightShift) const;

	Num<BitNum> operator>>(const int& i) const;

	//注意，这里的左移操作会保持符号位不变
	Num<BitNum> operator<<(const int& i) const;

	//改变比特数，增大比特数时，左侧填充符号位；减小比特数时，符号位保留，数值直接截断
	template<int NewBitNum>
	Num<NewBitNum> changeBit() const;

	//取出数值的某一位的值
	bool operator[](const int& bit) const;

	static constexpr int getBitNum();

	ValueType getRawValue() const;

private:
	ValueType _value;

	//所谓的 regulation ，指将 ValueType 中左侧没有用到的比特全部改为与符号位一致
	//以达到保证 _value 的整数值和我们想要表达的值确实一直的目的
	void _regulation();
};



//用来传递指令之类的限定比特位数的无符号整数
//可以方便的取出某几位来
template<int BitNum>
class Inst
{
public:
	typedef uint32_t ValueType;

	static_assert(BitNum > 0);
	static_assert(BitNum <= sizeof(ValueType) * 8);

	Inst(const ValueType& value = 0);

	void set(const ValueType& value);

	Inst<BitNum>& operator=(const ValueType& value);

	ValueType getRaw() const;

	bool get(int bit) const;

	ValueType get(int bitEnd, int bitBeg) const;

	void setBit(int bit, const bool& v);

	void setBit(int bitEnd, int bitBeg, const ValueType& v);

	//All six relational operators are automatically generated by the 
	//compiler if the three-way comparison operator operator<=> is defined
	//since c++20
	//for now...

	bool operator==(const ValueType& value) const;

	template<int BitNum2>
	bool operator==(const Inst<BitNum2>& inst) const;

	bool operator!=(const ValueType& value) const;

	template<int BitNum2>
	bool operator!=(const Inst<BitNum2>& inst) const;

	bool operator<(const ValueType& value) const;

	template<int BitNum2>
	bool operator<(const Inst<BitNum2>& inst) const;

	bool operator>(const ValueType& value) const;

	template<int BitNum2>
	bool operator>(const Inst<BitNum2>& inst) const;

	bool operator<=(const ValueType& value) const;

	template<int BitNum2>
	bool operator<=(const Inst<BitNum2>& inst) const;

	bool operator>=(const ValueType& value) const;

	template<int BitNum2>
	bool operator>=(const Inst<BitNum2>& inst) const;

private:
	ValueType _value{};
};

#include "define.hpp"
