#include "mem_hub.h"
#include "helper.h"
#include <complex.h>

void Mem_hub::readInput(	
	const std::string& path,
	size_t batchBegin,
	size_t batch
)
{
	std::bitset<128> a;
	//input twiddle factor
	//a = 0b01111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111100000000000000000000000000000000;
	
	a = 0b0;
	x_sram.push_back(a);
	//a = 0b01111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111100000000000000000000000000000000;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);
	//a = 0b1;
	x_sram.push_back(a);


	std::vector<std::array<Num<NUM_LEN>, 128>> tempVec;
	tempVec.resize((512 / 64) * batch/2);

	for (size_t index = 0; index < batch; index += 2)
	{
		const auto file1 = path + (std::to_string(batchBegin + index) + "_input.txt");
		const auto file2 = path + (std::to_string(batchBegin + index + 1) + "_input.txt");

		std::ifstream fin1(file1);
		std::ifstream fin2(file2);
		if (!fin1 || !fin2)
		{
			throw std::runtime_error("Error opening file");
		}

		double num1, num2;
		
		for (int i = 0; i < 512; i++)
		{
			fin1 >> num1;
			fin2 >> num2;

			//num2 = 0;

			//补0
			if(!fin1 || !fin2)
			{
				num1 = num2 = 0;
			}

			num1 = std::round(num1);
			num2 = std::round(num2);

			tempVec[(i / 64)*batch/2 + index/2][i % 64]
				= std::lround(num1 * std::pow(2, NUM_FRAC_BITS));
			tempVec[(i / 64)*batch/2 + index/2][i % 64+64] =
				std::lround(num2 * std::pow(2, NUM_FRAC_BITS));
		}

		fin1.close();
		fin2.close();
	}

	for(auto& tempArr: tempVec)
	{
		std::bitset<128> tempSets[NUM_LEN];
		for (int k = 0; k < NUM_LEN; k++)
		{
			for (int i = 0; i < 128; i++)
			{
				tempSets[k][i] = tempArr[i].getBit(NUM_LEN - 1 - k);
			}
		}
		for (auto& tempSet : tempSets)
		{
			x_sram.push_back(tempSet);
		}
	}
}

void Mem_hub::readWeightInput(
	const std::string& fileReal,
	const std::string& fileImag,
	bool layer3
)
{
	const size_t LineMax = layer3 ? 1 : 8;

	std::ifstream fin_real(fileReal);
	std::ifstream fin_imag(fileImag);
	if (!fin_real || !fin_imag)
	{
		throw std::runtime_error("Error opening file");
	}

	double weightR[8][8][64], weightI[8][8][64];
	std::bitset<128> tempSets[NUM_LEN];

	for (size_t j = 0; j < 8; j++)
	{
		for (size_t i = 0; i < LineMax; i++)
		{
			for (size_t k = 0; k < 64; k++)
			{
				//注意这里的下标顺序
				fin_real >> weightR[i][j][k];
				fin_imag >> weightI[i][j][k];
			}
		}
	}
	//先是前四行w,然后是后四行w
	for (size_t line = 0; line < LineMax; line += 4)
	{
		for (size_t part = 0; part < 4; part++)
		{
			for (size_t j = 0; j < 8; j++)
			{
				for (size_t i = line; i < std::min(line + 4, LineMax); i++)
				{
					for (size_t k = part * 16; k < part * 16 + 16; k++)
					{
						const Num<NUM_LEN> tempR =
							std::lround(weightR[i][j][k] * std::pow(2, WNUM_FRAC_BITS));
						const Num<NUM_LEN> tempI =
							std::lround(weightI[i][j][k] * std::pow(2, WNUM_FRAC_BITS));

						for (int bit = 0; bit < NUM_LEN; bit++)
						{
							tempSets[bit][(i % 4) * 32 + k % 16] =
								tempR.getBit(NUM_LEN - 1 - bit);
							tempSets[bit][(i % 4) * 32 + k % 16 + 16] =
								tempI.getBit(NUM_LEN - 1 - bit);
						}
					}
				}
				for (auto& tempSet : tempSets)
				{
					FFTw_sram.push_back(tempSet);
				}
			}
		}
	}

	if(layer3)
	{
		FFTw_sram.resize(768);
	}

	fin_real.close();
	fin_imag.close();
}

void Mem_hub::readBiasInput(const std::string& file)
{
	std::ifstream fin(file);
	if (!fin)
	{
		throw std::runtime_error("Error opening file");
	}
	double num;
	bool finished = false;
	std::bitset<128> tempSets[NUM_LEN];
	for (size_t i = 0; fin >> num; i = (i + 1) % 128)
	{
		finished = false;

		const Num<NUM_LEN> tempNum = std::lround(num * std::pow(2, NUM_FRAC_BITS));
		for(int bit =0;bit<NUM_LEN;bit++)
		{
			tempSets[bit][i] = tempNum.getBit(NUM_LEN - 1 - bit);
		}

		if (i == 127)
		{
			finished = true;
			for(auto& set: tempSets)
			{
				FFTw_sram.push_back(set);
			}
		}
	}
	//如果最后一次读入还没有被push
	if(!finished)
	{
		for (auto& set : tempSets)
		{
			FFTw_sram.push_back(set);
		}
	}

	if (FFTw_sram.size() < 816)
	{
		FFTw_sram.resize(816);
	}

	fin.close();
}

void Mem_hub::generate(const std::string& outFile) const
{
	/*FILE * fp;
	if(fopen_s(&fp, outFile.c_str(), "w"))
	{
		throw std::runtime_error("Error opening file");
	}
	
	fprintf(fp, "//Generated by Liu Ruoyang (lone_wolf_akela@qq.com)\n");
	fprintf(fp, "module DATA_ROM(\n");
	fprintf(fp, "\tinput wire [31:0] data_count,\n");
	fprintf(fp, "\toutput reg [151:0] rom_out,\n");
	fprintf(fp, "\toutput wire [31:0] total_counts\n");
	fprintf(fp, ");\n");
	fprintf(fp, "\n");
	fprintf(fp, "//rom_out part\n");
	fprintf(fp, "//[151:148] choose\n");
	fprintf(fp, "//[147:144] width\n");
	fprintf(fp, "//[143:128] addr\n");
	fprintf(fp, "//[127:0] data\n");
	fprintf(fp, "always @(*)\n");
	fprintf(fp, "case(data_count)\n");

	uint32_t count = 11;
	uint16_t addr = 0;
	fprintf(fp, "\t//x_sram\n");
	for (auto &set : x_sram)
	{
		fprintf_s(
			fp, "\t32'h%08x: rom_out = {4'd1,4'd8,16'h%04hx,128'b%s};\n",
			count++, addr++,
			set.to_string().c_str()
		);
	}

	fprintf(fp, "\t//Skip FFTx_sram\n");
	//count++;

	addr = 0;
	fprintf(fp, "\t//FFTw_sram\n");
	for (auto &set : FFTw_sram)
	{
		fprintf_s(
			fp, "\t32'h%08x: rom_out = {4'd3,4'd8,16'h%04hx,128'b%s};\n",
			count++, addr++,
			set.to_string().c_str()
		);
	}

	addr = 0;
	fprintf(fp, "\t//inst_sram\n");
	for (auto inst : inst_sram)
	{
		fprintf(
			fp, "\t32'h%08x: rom_out = {4'd5,4'd2,16'h%04hx,96'd0,32'h%08x};\n",
			count++, addr++, inst.getRaw()
		);
	}

	fprintf(fp, "\n");
	fprintf(fp, "\tdefault: rom_out = 152'd0;\n");
	fprintf(fp, "endcase\n");
	fprintf(fp, "\n");
	fprintf(fp, "assign total_counts = 32'h%08x;\n", count);
	fprintf(fp, "endmodule\n");

	fclose(fp);*/
}
